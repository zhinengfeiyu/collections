#### View的事件体系
1. View接收到ACTION_DOWN事件时，会先停止内部的滚动
2. 在View默认的dispatchTouchEvent中，如果enabled为true，则先调onTouchListener的onTouch方法，如果为true，
    则不会再调onTouchEvent，直接返回true；如果enabled为false，则不会调onTouchListener的回调，
    而是直接在onTouchEvent中返回clickable参数
3. 只有在enabled属性为true时，才会调用OnTouchListener；onTouchEvent的调用不受enabled限制
4. View自带的onTouchEvent只用于处理click事件、longClick事件、contextClick事件。  
    以上事件只要有一个，就返回true；否则返回false
5. 在ACTION_DOWN过程，如果子View确定处理事件，后续的ACTION_MOVE和ACTION_UP都还会调用父View的onIntercept；
    但是如果当前父View确定处理事件，则后续的ACTION_MOVE和ACTION_UP不会调用父View的onIntercept
6. onClick事件在ACTION_UP时触发
7. 判断哪些View可能处理事件，根据ACTION_DOWN的位置，后续的MOVE和UP可以超出处理事件的View的边界，  
    所以event的X和Y坐标可以小于0
8. OnKeyListener的onKey事件如果返回true，则系统默认的处理会不执行，只执行onKey方法
9. enabled为false的View，onTouchEvent直接返回clickable的值，即不做任何响应，直接返回是否消耗事件，且不会变为pressed状态
10. 在View默认的onTouchEvent接收到ACTION_MOVE时，仅处理移出View的区域时，从pressed状态变为普通状态，
    且后续的ACTION_MOVE事件保持该状态
11. 在View默认的onTouchEvent回调中，只要clickable为true，就一定会消耗事件
12. setOnClickListener方法，即使传递null进去，仍然会把clickable置为true
13. ViewGroup没有自己的onTouchEvent方法，View没有onInterceptTouchEvent方法
14. 每次重启一个新的事件序列，ViewGroup的diallowIntercept标记位会重置，不会使用上个事件序列的值
15. 在ACTION_DOWN时，只要父View调用了默认的dispatchTouchEvent，并且onInterceptTouchEvent返回false，
    则子View一定会收到ACTION_DOWN事件；但是如果子View在ACTION_DOWN时没有消费事件，则后续事件一定不会传给它
16. ViewGroup如果没有子View消费事件，而是自己消费事件，则不会直接调onTouchEvent，而是调View类的dispatchTouchEvent
17. 在内部拦截法子View在某个条件下调用requestDisallowTouchEvent之后，父View在该条件下onInterceptTouchEvent必须返回true；
    拦截成功之后，子View会接收到一个ACTION_CANCEL事件，然后不再获取后续事件
18. ViewGroup的DISALLOW_INTERCEPT标记位默认不存在，即在子View没有requestDisllow时，
    默认事件序列的每个动作都会调用onIntercept方法询问自己是否拦截