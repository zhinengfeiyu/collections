#### 关于Queue接口
- Queue接口继承了Collection接口，有很多跟List接口共用的方法，如add(),size(),contains(),isEmpty()等等
- 总共6个方法，但是实际执行3个功能，只是失败的时候是否抛异常的区别，add()和offer()是插入元素，
    remove()和poll()是移除头部节点并返回，element()和peek()是返回头部节点
    
#### 关于BlockingQueue接口
- BlockingQueue接口继承Queue接口，功能是在Queue的基础上，增加了获取元素时等待队列不为空，以及插入元素时等待队列
    腾出空间的两大功能

#### HashMap实现细节
HashMap可以使用null键。

jdk1.8前是数组+链表，1.8及之后是数组+链表/红黑树。

数组的大小永远都是2的幂次方，默认是16。如果构造函数里传入初始容量，会把初始数组大小置为比该初始容量大的，且最接近的2的幂次方。

key的相等性判断使用的是equals。

数组内存分配采用懒加载方式，即没有实际put元素的情况下数组不分配内存，只有在第一次put操作时才根据指定初始容量分配该容量大小的数组内存。

loadFactor默认是0.75。当HashMap已经put的元素个数达到数组容量*loadFactor，会把数组容量扩大为原来的2倍，并把原来的元素迁移过去。

触发数组扩容的另一个情况是，当数组容量小于64，且在某次put操作时某个链表即将达到数量上限8变成红黑树。
如果数组容量当前大于等于64，这种case不会触发数组扩容，而是触发链表变成红黑树。

红黑树和链表的切换时机，触发的元素个数不一样。链表转为红黑树的时机是元素个数即将变为8，红黑树转为链表的时机是元素个数即将变为6。

确定某个元素应该放在数组的哪个下标里面，会把hash值的高16位和低16位做异或操作，增强随机性，再除以数组大小取余（实际是位运算），即模运算。

用另一个Map去构造HashMap，或者执行putAll操作，实际上也是一个个元素往里面put的，只是初始容量大小会适配put进来的Map。
