#### 关于Queue接口
- Queue接口继承了Collection接口，有很多跟List接口共用的方法，如add(),size(),contains(),isEmpty()等等
- 总共6个方法，但是实际执行3个功能，只是失败的时候是否抛异常的区别，add()和offer()是插入元素，
    remove()和poll()是移除头部节点并返回，element()和peek()是返回头部节点
    
#### 关于BlockingQueue接口
- BlockingQueue接口继承Queue接口，功能是在Queue的基础上，增加了获取元素时等待队列不为空，以及插入元素时等待队列
    腾出空间的两大功能

#### HashMap实现细节
HashMap可以使用null键。

jdk1.8前是数组+链表，1.8及之后是数组+链表/红黑树。

数组的大小永远都是2的幂次方，默认是16。如果构造函数里传入初始容量，会把初始数组大小置为比该初始容量大的，且最接近的2的幂次方。

key的相等性判断使用的是equals。

数组内存分配采用懒加载方式，即没有实际put元素的情况下数组不分配内存，只有在第一次put操作时才根据指定初始容量分配该容量大小的数组内存。

loadFactor默认是0.75。当HashMap已经put的元素个数达到数组容量*loadFactor，会把数组容量扩大为原来的2倍，并把原来的元素迁移过去。

触发数组扩容的另一个情况是，当数组容量小于64，且在某次put操作时某个链表即将达到数量上限8变成红黑树。
如果数组容量当前大于等于64，这种case不会触发数组扩容，而是触发链表变成红黑树。

红黑树和链表的切换时机，触发的元素个数不一样。链表转为红黑树的时机是元素个数即将变为8，红黑树转为链表的时机是元素个数即将变为6。

确定某个元素应该放在数组的哪个下标里面，会把hash值的高16位和低16位做异或操作，增强随机性，再除以数组大小取余（实际是位运算），即模运算。

用另一个Map去构造HashMap，或者执行putAll操作，实际上也是一个个元素往里面put的，只是初始容量大小会适配put进来的Map。

#### CopyOnWriteArrayList和CopyOnWriteArraySet
CopyOnWriteXXX的使用场景：多线程并发的场景，且读操作的频率远远高于写操作

执行读操作不会进行任何加锁操作（核心优势）；写操作开销很大，每个写操作都在synchronized里执行，而且都会把所有元素复制到一个新的数组对象，
然后把新的对象赋给当前的数组变量

iterator迭代过程中不允许执行任何写操作，会直接抛异常。
迭代器创建时会把当前的数组对象构造进去，保证迭代过程针对的是同一个对象。

注意这个内部的数组对象用了volatile修饰，意味着更改能立即让其他线程可见。
所以迭代遍历过程一定要用iterator实现，而不能用for循环比较size后手动get，如果过程中有别的线程执行写操作很可能下标越界

CopyOnWriteArraySet是完全基于CopyOnWriteArrayList实现的，跟ArraySet的实现方式没有任何关联。内部有一个CopyOnWriteArrayList对象，所有读写操作
都委托给这个对象实现

Map没有对应的CopyOnWrite类
