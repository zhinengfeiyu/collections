## 泛型
1. Java的泛型方法声明，泛型<T>必须声明在返回值之前，不能声明在其他位置，泛型方法的泛型与它所在的类无关；Kotlin的<T>必须声明在方法名前，也不能声明在其他位置
2. 泛型擦除后到JVM中不一定都是Object，如果指定了上界则是第一个上界类型，即如果是extends A，则是A类型，如果是super A，则是Object类型
3. 因为泛型擦除的存在，可以通过反射调用绕过编译期泛型检查添加一个不同类型的参数
4. Kotlin和Java声明时都可以指定多个边界，但是只能有一个边界是类，且必须放在最前面；通配符后面不能指定多个边界
5. 使用通配符的好处是扩大了泛型可以传的类型范围，代价是限制了只能调用类里面的读方法或者只能调写方法
6. 所谓泛型只能输入或者输出，输入是指泛型出现在成员方法的参数位置，输出是指泛型出现在成员方法的返回值位置
7. 对于不指定界限的通配符，本质也是带有上界的通配符，上界类型即为类声明时的泛型上界，即对于AA<T>，AA<*>即为AA<* extends Object>，对于AA<T: B>，AA<*>即为AA<* extends B>。此时AA<*>即限定了只能进行读操作
8. 单个类里面通过静态的方式总能拿到泛型类型，即使就是声明时的T，但是通过创建的对象是拿不到的
9. 上面说的对于通配符声明的对象只能进行读或写操作只是笼统的说法，事实对于<* extends XX>，可以写但只能写入null（Kotlin中的Nothing类型）；对于<* super XX>，可以读但只能读到类声明时的上界类型，即跟XX类型是无关的
   
